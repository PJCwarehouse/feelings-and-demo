struct NodeP{
    T date;
    Node* prev;
    Node* next;
    Node(T d,Node* p,Node* n){}
    Node():prev(nullptr),next(nullptr){}
};

class Iterator{
    public:
    Iterator():current(nullptr){}
    Iterator& operator++(){
        current = current->next;
        return *this;
    }
    Iterator& operator++(int){
        Iterator old = *this;
        ++(*this);
        return old;
    }
    Iterator& operator--(int){
        Iterator old =*this;
        --(*this);
        return old;
    }
    T& operator*(){return current->data;}

    bool opertor==(const Iterator& x){return this->current == x.current}
    bool opertor!=(const Iterator& x){return this->current != x.current}
    protected:
    Node* current;
    Iterator(Node* p):current(p){}
    friend class List<T>;
}


List(){init();}

void init(){
    theSize = 0;
    head = new Node;
    tail = new Node;
    head->next = tail;
    tail->prev = next;
}

~List(){
    clear();
    delete head;
    deleta tail;
}

void clear(){
    while(!empty()) 
    pop_front();
}

List(const List& rhs){
    init();*this = rhs
}
List& operator = (List& rhs){
    if(this == &rhs)
    return *this;
    clear();
    for(Iterator itr = rhs.begin();itr != rhs.end();++itr){
        push_back(x: *itr)
    }
    return *this;
}

void push_front(const T& x){
    Node* newFront = new Node(x,head,head->next);
    head->next->prev = new  Front;
    head->next = newFront;
    thisSize++;
}
void push_back(const T& x){
    Node* newBack = new Node(x,tail->prev,tail);
    tail->prev->next = newBack;
    tail->prev = newBack;
    thsSize++;
}

T& pop_front(){
    if(empty()) throw"ListEmpty";
    Node* delItm = head->next;
    head->next = delItm->next;
    delItm->next->prev = head;
    delete delItm;
    thisSize--;
}

T& pop_back(){
    if(empty()) throw"ListEmpty";
    Node* delItm = tail->prev; 
    delItm->prev->next = tail;
    tail->prev = delItm->prev;
    delete delItm;
    thisSize--;
}

Iterator erase(Iterator itr){
    Node* p = itr.current;
    Iterator retVal(p->next);
    p->prev->next = p->next;
    p->next->prev = p-prev;
    delete p;
    thisSize--;
    return reVal;
}
Iterator erase(Iterator start,Iterator end){
    for(Iterator itr = start;itr != end;){
        itr = erase(itr);
    }
    return end;
}

5
int size(){return theSize;}
bool empty(){return size() == 0;}

6
Iterator begin(){
    return Iterator(head->next);
}
Iterator end(){
    return Iterator(tail);
}
7
Iterator insert(Iterator itr,const T& x){
    Node* p = itr.current;
    sheSize;
    return Iterator(p->prev = p->prev->next = new Node(x,p->prev,p));
}
void splice(Iterator pos,List<T>& x){
    while(!(x.empty()))
        insert(itr:pos,x:x.pop_front());
        theSize += x.size();
}


实验结果
TEST(Constructor,Constructor__Test){
    List<int> first;
}

TEST(OperatorAssign,Operator_P_Test){
    List<int> l1;
    List<int> l2;
    for(int i=0;i<10;i++){
        l1.push_front(x:i);
    }
    l2 = l1;
    l1.printList();
    l2.printList();
}

Testing started at 19.53 ...
9 8 7 6 5 4 3 2 1 0
9 8 7 6 5 4 3 2 1 0

Test(BeginAndEnd,BeginAndEndTest){
    List<int> l;
    for(int i = 0;i < 10;i++){
        l.push_back(x:i);
    }
    for(List<int>::Iterator i = l.begin();i != l.end();++i){
        cout<<*i<<" ";
    }
}

Testing started at 20:17 ...
0 1 2 3 4 5 6 7 8 9


TEST(empty,emptyTest){
    List<int> l1;
    List<int> l2;
    l2.push_back(x:10);
    cout<<l1.empty()<<" "<<l2.empty()<<endl;
}
Testing started at 20.19 ...
1 0

TEST(size,sizeTest){
    List<int> l1;
    for(int i = 0;i < 100;i++){
    l1.push_back(x:i);
    }
    cout<<l1.size()<<endl;
}
Testing started at 20.20 ...
100

TEST(pushFrontPushBcak,TestAdd){
    List<int> l;
    l.push_back(x:1);
    l.push_front(x:2);
    l.printList();
}

Testing started at 20.22 ...
2 1

TEST(popFrontPopBack,TestPop){
    List<int> l;
    l.push_back(x:1); 
    l.push_back(x:2);
    l.pop_back();
    l.pop_front();
    l.printList();
}
Testing started at 20.24 ...
this list is empty


TEST(insert,insertTest){
    List<int> l;
    for(int i = 0;i<10;++i){
        l.push_back(x:i);
    }
    l.printList();
    List<int>::Iterator it = l.begin();
    l.insert(itr:it,x:10);
    it = l.end();
    l.insert(itr:it,x:11)
    l.printList();
}
Testing started at 20.27 ...
0 1 2 3 4 5 6 7 8 9
10 0 1 2 3 4 5 6 7 8 9 11

TEST(insert,insertTset){
    List<int> l;
    for(int i = 0;i<10;++i){
        l.push.back(x:i);
    }
    l.printList();
    List<int>::Iterator it = l.begin();
    l.insert(itr:it,x:10);
    it = l.end();
    l.insert(itr:it,x:11);
    l.printList
}
Testing started at 20.30 ...
1 2 3 4 5 6 7 8 9

TEST(eraseFT,eraseFT__Test){
    List<int> l;
    for(int i = 0;i<10;++i){
        l.push_back(x:i);
    }
    List<int>::Iterator it1 = l.begin();
    List<int>::Iterator it2 = l.end();
    l.erase(start:it1,end:it2);
    l.printlist();
}
Testing started at 20.32 ...
this list is empty