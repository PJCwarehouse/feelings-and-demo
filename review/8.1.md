#redis
###应用场景
一.缓存

Redis作为一种内存数据库，具有快速的数据访问和高效的数据存储，适合用作缓存的存储层。Redis可以缓存数据的计算结果、页面内容、数据库查询结果等，通过提高数据访问速度和响应速度，提升系统性能和用户体验。
访问流程一般为：
第一次访问：用户请求访问->缓存(缓存中不存在)->数据库(将数据存储到缓存中)->用户请求到信息
第二次访问：用户请求访问->缓存(缓存中存在)->用户请求到信息
访问直接从缓存中读取速度就会快很多
*用空间换取时间*

二.消息队列
Redis可以作为一种高性能的消息队列使用，实现异步处理和解耦。Redis支持列表数据类型，可以将消息存储在列表中，并且支持阻塞式操作，可以实现消息队列的等待和通知机制。

目前在市面上比较主流的消息队列中间件主要有，Kafka、ActiveMQ、RabbitMQ、RocketMQ 等这几种。

ActiveMQ和RabbitMQ这两着因为吞吐量还有GitHub的社区活跃度的原因，在各大互联网公司都已经基本上绝迹了，业务体量一般的公司会是有在用的，但是越来越多的公司更青睐RocketMQ这样的消息中间件了。

Kafka和RocketMQ一直在各自擅长的领域发光发亮，不过大厂应该都是使用各自的中间件，可能做过修改，也可能是自研的，大多没有开源。


定义
1、消息队列是一种先进先出的队列型数据结构，实际上是系统内核中的一个内部链表。消息被顺序插入队列中，其中发送进程将消息添加到队列末尾，接受进程从队列头读取消息。
2、多个进程可同时向一个消息队列发送消息，也可以同时从一个消息队列中接收消息。发送进程把消息发送到队列尾部，接受进程从消息队列头部读取消息，消息一旦被读出就从队列中删除。
三. 分布式锁
Redis可以作为一种分布式锁的存储层，通过缓存锁信息和锁状态，实现分布式锁和并发控制。Redis支持多种数据类型，包括字符串、哈希、列表、集合和有序集合，可以根据不同的场景选择合适的数据类型来实现分布式锁。


###Redis的优缺点
Redis具有以下优点：

快速：Redis使用内存存储数据，读写速度非常快。

多种数据类型：Redis支持多种数据结构，可以适应不同的应用场景。

丰富的特性：Redis支持事务、Lua脚本、发布订阅模式等高级特性。

可扩展性：Redis可以通过主从复制、哨兵模式和集群模式等方式实现高可用和横向扩展。

Redis也有一些缺点：

内存限制：由于Redis使用内存存储数据，因此受到内存容量的限制。

持久化问题：Redis默认不会将数据持久化到硬盘，需要使用持久化机制来解决数据丢失问题。

单线程模型：Redis采用单线程模型，虽然可以通过多实例和多线程方式解决并发问题，但是并发能力相对较弱。

主从复制：

Redis 的主从复制是实现高可用的基础。主从复制的作用是将主节点的数据复制到从节点上，当主节点出现故障时，从节点可以接替主节点，继续提供服务。

在 Redis 中，主节点负责写操作，从节点只负责读操作。当主节点出现故障时，从节点会自动升级为主节点，继续提供写操作。

主从复制的实现有两种方式：异步复制和半同步复制。异步复制的实现简单，但可能会出现数据丢失的情况。半同步复制的实现复杂，但可以保证数据不丢失。

哨兵模式：

哨兵模式是 Redis 提供的一种高可用性解决方案。哨兵的作用是监控 Redis 的主从节点是否正常工作，当发现节点出现故障时，自动将从节点晋升为主节点，继续提供服务。

哨兵通常运行在独立的服务器上，与 Redis 实例分开部署，以防单点故障。

哨兵可以同时监控多个 Redis 实例，并且可以自动进行故障转移，保证服务的可用性。

集群模式：

Redis通过集群模式实现数据的分片和负载均衡。集群模式可以将数据分布到多个节点上，每个节点负责存储部分数据。当需要读取数据时，客户端可以根据key的hash值定位到对应的节点进行读取，实现负载均衡和横向扩展。



**小知识**
相对路径：回退到上一级目录为../,同级目录直接使用

同一个包之间的类可以直接调用和实例化
例如：
>// 类A
public class ClassA {
    public void methodA() {
        // 调用类B的方法
        ClassB classB = new ClassB();
        classB.methodB();
    }
}

>// 类B
public class ClassB {
    public void methodB() {
        // 方法实现
    }
}

不同包之间一般调用@Autowired注解，来方便实例化
@Autowired相当于下面的步骤
   
    public class SomeClass {
        private UserService userService;

        public SomeClass() {
            // 创建UserService实例并分配给userService变量
            userService = new UserService();
        }

        public void doSomething() {
            // 可以使用userService对象进行操作
            userService.someMethod();
        }
    }


用new创建实例：
1.new关键字是Java语言用于创建对象实例的关键字。
2.通过new关键字，可以手动创建一个类的实例，并在内存中分配空间给它。
3.new关键字主要用于创建非Spring管理的对象实例，通常是在本地类或外部库中实例化对象。
4.在使用new创建实例时，需要确保**目标类在类路径**中，并且访问权限允许进行实例化。

@Autowired通常用于将不同包或模块中的bean自动注入到类中，这样可以减少手动创建实例的繁琐工作，并使代码更加灵活和可维护。在Spring框架中，@Autowired可以自动完成依赖注入，将需要的bean自动注入到类中，让开发人员专注于业务逻辑的实现，而不用过多关心对象的实例化和管理。


**总结**
@Autowired是Spring框架用于依赖注入的机制，用于自动将bean注入到类中，减少手动创建对象的工作。
new关键字是Java语言用于手动创建对象实例的方式，在没有使用Spring的情况下，可以用于创建类的对象。
跨包调用就添加注解@Autowired创建对象，方便
@Autowired
    public SecurityConfig(UserService userService) {
        this.userService = userService;
    }